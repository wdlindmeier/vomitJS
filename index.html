
<html>
<head>
  <title>PeerJS - Video chat example</title>
  <link rel="stylesheet" href="style.css">
  <script>
  var $MouthX = 0;
  var $MouthY = 0;
  var $MouthZ = 0;
  </script>
  <script type="text/javascript" src="jquery.min.js"></script>
  <script type="text/javascript" src="http://cdn.peerjs.com/0.3/peer.js"></script>
  <script type="text/javascript" src="speech.js"></script>
  <script type="text/javascript" src="model_pca_20_svm.js"></script>
  <script type="text/javascript" src="clm.js"></script>
  <script type="text/javascript" src="chat.js"></script>
  <script src="three.min.js"></script>
</head>

<body>

  <div id="container" class="pure-g">

    <!-- Video area -->
    <div class="pure-u-2-3" id="video-container">
      
      <div id="them">      
        <video id="their-video" width="640" height="480" autoplay></video>
        <canvas id="them_overlay" width="640" height="480" ></canvas>
      </div>
      
      <div id="me">
        <video id="my-video" width="280" height="210" muted="true" autoplay></video>
        <canvas id="me_overlay" width="280" height="210" ></canvas>
      </div>
      
      <div id="positions"></div>

    </div>

    <!-- Steps -->
    <div class="pure-u-1-3">
      <h2>Vomitorium</h2>
      <!-- Get local audio/video stream -->
      <div id="step1">
        <p>Please click `allow` on the top of the screen so we can access your webcam and microphone for calls.</p>
        <div id="step1-error">
          <p>Failed to access the webcam and microphone. Make sure to run this demo on an http server and click allow when asked for permission by the browser.</p>
          <a href="#" class="pure-button pure-button-error" id="step1-retry">Try again</a>
        </div>
      </div>

      <!-- Make calls to others -->
      <div id="step2">
        <p>Your id: <span id="my-id">...</span></p>
        <p>Share this id with others so they can call you.</p>


        <h3>Make a call</h3>
        <div class="pure-form">
          <input type="text" placeholder="Call user id..." id="callto-id">
          <a href="#" class="pure-button pure-button-success" id="make-call">Call</a>
        </div>
      </div>

      <!-- Call in progress -->
      <div id="step3">
        <p>Currently in call with <span id="their-id">...</span></p>
        <p><a href="#" class="pure-button pure-button-error" id="end-call">End call</a></p>
      </div>

      <div id="step5">

        <div class="pure-form">
          <input type="text" placeholder="Message to send..." id="data-msg">
          <a href="#" class="pure-button pure-button-success" id="send-data">Send</a>
        </div>

        <!--div class="pure-form">
          <a href="#" class="pure-button pure-button-success" id="start-speech">Start speech</a>
          <a href="#" class="pure-button pure-button-success" id="start-tracking">Start tracking</a>
        </div-->
          
      </div>

    </div>
  </div>

  <script>
	var camera, scene, renderer;
	// var geometry, material, mesh;
  var cubes = [];

  var $VidWidth = 640;
  var $VidHeight = 480;
  var $SpeedMulti = 4.0;
  var Cube = function(x,y,z)
  {
    this.geometry = new THREE.CubeGeometry( 100, 100, 100 );
		this.material = new THREE.MeshBasicMaterial( { color: 0xff0000, wireframe: true } );    
    this.mesh = new THREE.Mesh( this.geometry, this.material );
    this.mesh.position = new THREE.Vector3(x,y,z);
    this.velocity = new THREE.Vector3(Math.random() * 2 - 1, -0.9, Math.random() * 2 - 1); 
    this.isDead = false;
    return this;
  }

	function init() {

		camera = new THREE.PerspectiveCamera( 45, $VidWidth / $VidHeight, 1, 10000 );
    // NOTE: This cam position is designed to make the scene 640x480 units 
    // at a Z Depth of 100, so we can treat them like pixels.
		camera.position.z = 680; 

		scene = new THREE.Scene();

		// geometry = new THREE.CircleGeometry(100, 30);
    // geometry = new THREE.CubeGeometry( 100, 100, 100 );
		// material = new THREE.MeshBasicMaterial( { color: 0xff0000, wireframe: true } );
    // 
		// mesh = new THREE.Mesh( geometry, material );
    // addCube(0,0,100);
    
		renderer = new THREE.CanvasRenderer();
		renderer.setSize( $VidWidth, $VidHeight );

    var threeCanvas = renderer.domElement;
    var oldCanvas = $('#them_overlay')[0];
    oldCanvas.parentNode.replaceChild(threeCanvas, oldCanvas);
		//document.body.appendChild( threeCanvas );
    threeCanvas.id = 'them_overlay';

	}
  
  function addCube(x,y,z)
  {
    var cube = null;
    // Recycle if possible
    for (var i = 0; i < cubes.length; i++)
    {
      var oldCube = cubes[i];
      if (oldCube.isDead)
      {
        cube = oldCube;
        cube.isDead = false;
        cube.mesh.position = new THREE.Vector3(x,y,z);
      }
    }
    if(cube == null)
    {
      cube = new Cube(x,y,z);
      scene.add( cube.mesh );
      cubes.push(cube);    
    }
    // console.log("Added cube to " + $MouthX + "," + $MouthY + "," + $MouthZ);
  }

	function animateVomit() {

		// note: three.js includes requestAnimationFrame shim
		// requestAnimationFrame( animate );

    var resetIndices = [];
    
    for (var i = 0; i < cubes.length; ++i)
    {
      var cube = cubes[i];
      
      cube.mesh.position.x += (Math.random() * 2 - 1) + cube.velocity.x * $SpeedMulti;
      cube.mesh.position.y += Math.random() + cube.velocity.y * $SpeedMulti;
      cube.mesh.position.z += Math.random() + cube.velocity.z * $SpeedMulti;

      cube.mesh.rotation.x += 0.01;
  		cube.mesh.rotation.y += 0.02;
      
      if (cube.mesh.position.y < -300)
      {
        cube.isDead = true;
        //resetIndices.push(i)
      }
    }

    // Recycle
    /*
    for (var i = 0; i < resetIndices.length; i++)
    {
      var oldCube = cubes[resetIndices[i]];
      oldCube.isDead = true;
  		scene.remove( oldCube.mesh );
      delete(oldCube);
      
      var cube = new Cube($MouthX,$MouthY,$MouthZ);
  		scene.add( cube.mesh );
      
      cubes[resetIndices[i]] = cube;
    }*/

		renderer.render( scene, camera );

	}
  
	init();
	//animate();
  
  </script>
</body>
</html>
